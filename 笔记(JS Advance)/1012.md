#方式1：原型链的继承
1. 套路
	1. 定义父类型构造函数
	2. 给父类型的原型添加方法
	3. 定义子类型的构造函数
	4. 创建父类型的对象赋值给子类型的原型
	5. 将子类型原型的构造属性设置为子类型
	6. 给子类型原型添加方法
	7. 创建子类型的对象: 可以调用父类型的方法
2. 关键
	1. 子类型的原型为父类型的一个实例对象
##代码详细解释
	function Supper() {
	    this.supProp = 'Supper property'
	  }
	  Supper.prototype.showSupperProp = function () {
	    console.log(this.supProp)
	  }
	
	  //子类型
	  function Sub() {
	    this.subProp = 'Sub property'
	  }
	
	  // 子类型的原型为父类型的一个实例对象
	  Sub.prototype = new Supper()
	  // 让子类型的原型的constructor指向子类型
	  Sub.prototype.constructor = Sub
	  Sub.prototype.showSubProp = function () {
	    console.log(this.subProp)
	  }
	
	  var sub = new Sub()
	  sub.showSupperProp()
	  // sub.toString()
	  sub.showSubProp()
	
	  console.log(sub)  // Sub
![](/img/1012/1.png)
##一点需要注意的问题
	在上述继承的过程中，如果缺少：Sub.prototype.constructor = Sub（让子类型的原型的constructor指向子类型）
	就会导致sub的constructor指向父类型
![](/img/1012/2.png)

	添加之后：
![](/img/1012/3.png)

#方式2：借用构造函数继承（假的）
1. 套路:
	1. 定义父类型构造函数
	2. 定义子类型构造函数
	3. 在子类型构造函数中调用父类型构造
2. 关键:
	1. 在子类型构造函数中通用call()调用父类型构造函数

#方式3：原型链+借用构造函数的组合继承
1. 利用原型链实现对父类型对象的方法继承
2. 利用super()借用父类型构建函数初始化相同属性

#线程与进程机制
1. JS是单线程运行的
2. 但使用H5中的Web Workers可以多线程运行
3. 浏览器是多线程运行的

![](/img/1012/4.png)

1. 进程：程序的一次执行, 它占有一片独有的内存空间
2. 线程： CPU的基本调度单位, 是程序执行的一个完整流程
3. 进程与线程
  * 一个进程中一般至少有一个运行的线程: 主线程
  * 一个进程中也可以同时运行多个线程, 我们会说程序是多线程运行的
  * 一个进程内的数据可以供其中的多个线程直接共享
  * 多个进程之间的数据是不能直接共享的
4. 浏览器运行是单进程还是多进程?
  * 有的是单进程
    * firefox
    * 老版IE
  * 有的是多进程
    * chrome
    * 新版IE
5. 如何查看浏览器是否是多进程运行的呢?
  * 任务管理器==>进程
6. 浏览器运行是单线程还是多线程?
  * 都是多线程运行的

1. 进程：程序的一次执行, 它占有一片独有的内存空间
2. 线程： CPU的基本调度单位, 是程序执行的一个完整流程
3. 进程与线程
  * 一个进程中一般至少有一个运行的线程: 主线程
  * 一个进程中也可以同时运行多个线程, 我们会说程序是多线程运行的
  * 一个进程内的数据可以供其中的多个线程直接共享
  * 多个进程之间的数据是不能直接共享的
4. 浏览器运行是单进程还是多进程?
  * 有的是单进程
    * firefox
    * 老版IE
  * 有的是多进程
    * chrome
    * 新版IE
5. 如何查看浏览器是否是多进程运行的呢?
  * 任务管理器==>进程
6. 浏览器运行是单线程还是多线程?
  * 都是多线程运行的