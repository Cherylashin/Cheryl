#测试题1：先执行变量提升，再执行函数提升
	function a(){}
	var a;
	console.log(typeof a);-------------function
#测试题2：变量提升
	if(!(b in window)){
            var b = 1;
        }
        console.log(b);-----------undefined
#测试题3：c已经赋值，为变量，不是函数
	var c = 1;
        function c(c){
            console.log(c);
            var c = 3;
        }
        c(2);
	报错：Uncaught TypeError: c is not a function

#复习
	函数对象有prototype属性
	函数也是特殊的实例对象，不过一般情况下实例对象指new 构造函数产生的对象
	Function的显式原型=隐式原型
![](/img/0916/1.png)

	一般情况下：实例对象的隐式原型=构造函数的显式原型
	例外：Object的显式原型不等于Object的隐式原型，Object的隐式原型为null
![](/img/0916/2.png)

	变量提升和函数提升的产生原因是执行上下文（栈）

#作用域
	分类：
		1. 全局作用域
		2. 函数作用域
		3. 没有块作用域，也就是大括号包裹（ES6有了）
			if(true){
            			var c = 3;
       		 }
        		console.log(c);--------3（在外部可以看到c）
	作用：
		隔离变量，不同作用域下同名变量不会有冲突
#作用域与执行上下文的区别
1. 区别一
	1. 全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时
	2. 全局执行上下文是在全局作用域确定之后，JS代码马上执行之前创建
	3. 函数执行上下文是在调用函数时，函数体代码执行之前创建
2. 区别2
	1. 作用域是静态的，只要函数定义好了就一直存在，且不会再变化
	2. 上下文是动态的，调用函数时创建，函数调用结束时就会自动释放
3. 联系
	1. 执行上下文（对象）是从属于所在的作用域
	2. 全局上下文环境==>全局作用域
	3. 函数上下文环境==>对应的函数使用域