#onmousemove
	鼠标移动事件：该事件将会在鼠标在元素中移动时被触发
#事件对象
	当事件的响应函数被触发时，浏览器每次都会将一个事件对象作为实参传递进响应函数
		在事件对象中封装了当前事件相关的一切信息，比如：
		鼠标的坐标 键盘哪个按键被按下 鼠标滚轮滚动的方向……
	clientX属性可以获取鼠标指针的水平坐标
	clientY属性可以获取鼠标指针的垂直坐标
![](/img/0807/1.png)

##clientX和clientY
	用于获取鼠标在当前的可见窗口的坐标
	而div的偏移量是相对于整个页面的
##pageX和pageY
	可以获取鼠标在当前整个页面的坐标

#事件的冒泡
	所谓的冒泡指的是事件的向上传导，当后代元素上的时间被触发时，其祖先元素的相同时间也会被触发
	在开发中，大多数时候冒泡是有用的
	如果不希望发生事件冒泡可以通过事件对象来取消冒泡cancelBubble
	s1.onclick = function(event){
                alert("我是span的单击响应函数");
                event.cancelBubble = true;
            };
#事件的委派
	指将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素
	事件委派是利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能
#事件的绑定
	使用对象.事件 = 函数		的形式绑定响应函数，它只能同时为一个元素的一个事件绑定一个响应函数，不能绑定多个
	如果绑定多厚，则后边会覆盖掉前边的
	
##addEventListener()
	通过这个方法也可以为元素绑定响应函数
	这种方式不会覆盖前边的响应函数
	可以为一个元素的相同事件同时绑定多个响应函数
	参数：
		1. 事件的字符串，不要on
		2. 回调函数，当事件触发时该函数会被调用
		3. 是否在捕获阶段触发事件，需要一个布尔值，一般都传false
	btn01.addEventListener("click",function(){
		alert(1);
       },false);
	btn01.addEventListener("click",function(){
		alert(2);
       },false);
#事件的传播
	关于事件的传播网景公司和微软公司有不同的理解
	微软公司：
		认为事件应该是由内向外传播，也就是当事件触发时，
		应该触发当前元素上的事件然后在向当前元素的祖先元素上传播，也就是说事件应该在冒泡阶段执行
	网景公司：
		认为事件应该是由外向内传播的，也就是当前事件触发时，应该先触发当前元素的最外层的祖先元素的事件
	W3C：
		综合了两个公司的方案，将事件传播分成了三个阶段
		1. 捕获阶段
			在捕获阶段时从最外层的祖先元素，想目标元素进行事件的捕获，但是默认此时不会触发事件
		2. 目标阶段
			事件捕获到目标元素，捕获结束后开始子啊目标元素上触发事件
		3. 冒泡阶段
			事件从目标元素向它的祖先元素传递，一次触发祖先元素上的事件
	-如果希望在捕获阶段就触发事件，可以将addEventListener()的第三个参数设置为true
		一般情况下我们不会希望在捕获阶段触发事件，所以这个参数一般都是false

#拖拽一
	1. 当鼠标在被拽元素上按下时，开始拖拽onmousedown
	2. 当鼠标移动时被拖拽元素跟随鼠标移动onmousemove
	3. 当鼠标松开时，被拖拽元素固定在当前位置onmouseup

#拖拽二
	让鼠标在哪里按下就停留在哪里，而不是跳回左上角

	clientX是鼠标的水平偏移量
	offsetLeft是元素的水平偏移量
	二者之差就是按下鼠标时元素应该在的位置
	var ol = event.clientX - box1.offsetLeft;
	var ot = event.clientY - box1.offsetTop;