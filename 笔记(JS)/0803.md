#函数作用域
	调用函数时创建函数作用域，函数执行完毕后函数作用域销毁
	每调用一次函数就会创建一个新的函数作用域，他们之间是互相独立的
##在函数中不使用var声明的变量都会成为**全局变量**
	b = 10
        function fun2(){
            // var声明提前但未赋值
            console.log(b);
            var b = "函数中的a";
            c = 10;	//虽然是在函数中定义的参数但未使用var相当于创建了全局变量
        }
        fun2();
        console.log(c);------------10

##添加形参之后相当于声明提前后续不加var赋值也不会影响全局变量的值
	// 添加形参
        d = 123;
        function fun3(d){---------------------相当于声明了局部变量d
            console.log(d);-----------------undefined-------------未赋值
            d = 456;----------------改变局部变量d不影响全局变量的值
        }
        fun3();----------------未传入参数
        console.log(d);--------------123
##Google的debug调试
	开发者工具->源代码->选中变量添加监听
![](/img/0803/1.png)

#this
	解析器在调用函数每次都会向函数内部传递进一个隐含的参数，这个隐含的参数就是this
	这个对象我们称为函数执行的上下文对象，根据函数的调用方式的不同，this会指向不同的对象
		1. 以函数的形式调用书，this永远都是window
		2. 以方法的形式调用时，this就是调用方法的那个对象
		function fun(){
			console.log(this.name);
		}
	        
		var obj = {
			name:"swk",
			sayName:fun
		};

		//以方法的形式调用，this表示的是obj对象的属性，obj.name=="swk"
		obj.sayName();---------------------------swk  
	
		name = "全局的name属性";
		//以函数形式调用，this表示的是window的属性，window.name="全局的name属性"
		fun(); ------------------------全局的name属性

#使用工厂方法创建对象（用的不多）
	function createPerson(name,age){
            var obj = new Object();

            obj.name = name;
            obj.age = age;
            return obj;
        }

        var obj3 = createPerson("zbj",20);
        console.log(obj3);-------------------{name: 'zbj', age: 20}

	使用工厂方法创建的对象使用的构造函数都是Object，
	所以创建的对象都是Object这个类型导致我们无法区分出多种不同的数据类型
#构造函数
	构造函数和普通函数的局别就是调用方式不同
		普通函数直接调用，构造函数：new 构造函数()
	构造函数的执行流程：
		1. 立刻创建一个新的对象
		2. 将新建的对象设置为函数中this，在构造函数中可以使用this来引用新建的对象(如下图中this相当于新建的obj对象)
		3. 逐行执行函数中的代码
		4. 将新建的对象作为返回值返回
![](/img/0803/2.png)

	使用instanceof可以检查一个对象是不是一个类的实例：
	语法：
		对象 instanceof 构造函数，是返回true
		console.log(obj instanceof Person);----------------true

##目前的构造函数的缺陷
![](/img/0803/3.png)

	在Person构造函数中，为每一个对象都添加了一个sayName方法，
	目前我们的方法是在构造函数内部创建的
		也就是构造函数每执行一次就会创建一个新的sayName方法
	也就是所有实例的sayName都是唯一的
	这样就导致了构造函数执行一次就会创建一个新的方法，这是完全没必要的，可以使所有的对象共享同一个方法

	1. 解决方案一：将sayName方法写到全局作用域中
		问题：将函数定义在全局作用域中，污染了全局作用域的命名空间
        	而且定义在全局作用域中也很不安全
![](/img/0803/4.png)

	2. 解决方案二：将方法写到原型对象里
		以后我们创建构造函数时，可以将这些对象共有的属性和方法添加进原型对象里，既不会污染全局作用域，也不用为每一个对象创建新的方法
![](/img/0803/6.png)	

##原型
	1. 我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype
	2. 这个属性对应这一个对象，这个对象就是我们所谓的原型对象
	3. 如果函数作为普通函数调用prototype没有任何作用
	4. 当函数以构造函数的形式调用时，他所创建的对象中都会有一个隐含的属性，指向该构造函数的原型对象，
		可以通过__proto__来访问该属性
	5. 原型对象就相当于一个公共区域，所有同一个类的实例都可以访问到这个原型对象
	6. 当我们访问对象的一个属性或方法的时候没有找到，则会去原型对象中寻找
![](/img/0803/5.png)

	原型对象也是对象，所以他也有原型，原型的原型没有原型
	hasOwnProperty("属性名");可以检查对象是否含有该属性
##垃圾回收（GC）
	程序运行过程中会产生垃圾，需要一个垃圾回收机制来处理垃圾
	在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁
	我们需要做的就是将不需要再使用的对象设置为null  obj = null

#数组
##数组的方法
	push()
		该方法可以向数组的末尾添加一个或多个元素，并返回数组的新的长度
		可以将要添加的元素作为方法的参数传递，这样浙西二元素将会自动添加到数组的末尾
	pop()
		删除数组的最后一个元素，并将删除的元素返回
![](/img/0803/7.png)
	
	unshift()
		向数组的开头添加一个或多个元素，并返回数组的新的长度
	shift()
		删除数组的第一个元素，并返回被删除的元素
###forEach()方法
	该方法需要一个函数作为参数
		由我们创建但是不由我们调用的函数我们成为回调函数
	数组中有几个元素就会执行几次，每次执行时，浏览器会将遍历到的元素
		以实参的形式传递进来，我们可以来定义形参，来读取这些内容
	浏览器会在回调函数中传递三个参数：
		1. 第一个参数，就是当前正在遍历的元素
		2. 第二个参数，就是当前正在遍历的元素的索引
		3. 第三个参数，就是正在遍历的数组
![](/img/0803/8.png)
![](/img/0803/9.png)
![](/img/0803/10.png)
###slice()和splice()
	slice()不会影响原数组
	splice()会影响到原数组，会将指定元素从原数组中删除并将被删除的元素作为返回值返回
		参数：
			第一个参数表示开始位置的所谓
			第二个参数表示删除的元素数量
			第三个及以后：
				可以传递一些新的元素，这些元素将会自动插入到开始位置索引前边
![](/img/0803/11.png)

![](/img/0803/12.png)

###concat()
	连接两个数组，不会改变原数组
	arr.concat(arr2);
###join()
	该方法可以将数组转换为一个字符串，不会改变原数组
	join()可以指定参数表示分隔符
	result1 = arr.join("--");
      console.log(result1);----------swk--zbj--shs
###reverse
	该方法用来反转数组，会对原数组产生影响
###sort()
	对数组元素进行排序，对原数组有影响
	arr3 = ['b','d','a','e','c'];
	arr3.sort();
	console.log(arr3);-------------['a','b','c','d','e']

	即使对于纯数字的数组，使用sort()排序是，也会按照Unicode编码来排序，所以对数字进行排序时，可能会得到错误的结果

	Unicode编码排序按照的是一位一位比较，比如23和4利用Unicode比较的时候，23首位是2，4首位是4，所以得到结果23<4

	因此，我们可以自己 来指定排序的规则
		我们可以在sort()添加一个回调函数，来指定排序规则
		回调函数中需要定义两个形参
		浏览器将会分别使用数组中的元素作为实参去调用回调函数
		使用那个元素调用不确定，但是肯定的是在数组中a一定在b前边
	浏览器会根据回调函数的返回值来决定元素的顺序
		如果返回一个大于0的值，则元素会交换位置
		如果返回一个小于0的值，则元素位置不变
		如果返回一个0，则认为两个元素相等，也不交换位置
	升序：return a-b;
	降序：return b-a;
![](/img/0803/13.png)

#函数对象的方法
##call和apply
	fun.call();
	fun.apply();
	这两个方法都是函数对象的方法，需要通过函数对象来调用
	当对函数调用call()和apply()都会调用函数执行
	在调用call()和apply可以将一个对象指定为第一个参数
	function fun(){
            console.log(this);------------------{name:'swk',age:18}
        }

        var obj = {name:'swk',age:18};
        fun.call(obj);

	通过call和apply修改this

	call()方法可以将实参在对象之后一次传递
	apply()方法需要将实参封装到一个数组中统一传递

##this的情况
	1. 以函数形式调用时，this永远都是window
	2. 以方法的形式调用时，this是调用方法的对象
	3. 以构造函数的形式调用时，this是新创建的那个对象
	4. 使用call和apply调用时，this是指定的那个对象

#arguments
	在调用函数时，浏览器每次都会传递进两个隐含的参数：
		1. 函数的上下文对象this
		2. 封装实参的对象 arguments
			arguments是一个类数组对象，它也可以通过索引来操作数据，也可以获取长度
			在调用函数时，我们所传递的实参都会在arguments中保存
	arguments有一个属性叫做callee，这个属性对应一个函数对象，就是当前正在指向的函数的对象

#Date对象
	在JS中使用Date对象来表示一个时间
	日期格式：月份/日/年 时:分:秒
	var d2 = new Date("03/04/2004 3:04:04");
	console.log(d2);--------------Thu Mar 04 2004 03:04:04 GMT+0800 (中国标准时间)
##Date对象的方法
###getDate()
	返回 日
	var date = d2.getDate();
	console.log(date);--------4
###getDay()
	返回 周几
	var date1 = d2.getDay();
	console.log(date1);--------------4（代表周四）
###getMonth()
	返回月份 0代表1月 1代表2月
	var date2 = d2.getMonth();
	console.log(date2);
###getTime()
	// 获取当前日期对象的时间戳
	// 时间戳指的是从格林威治标准时间的1970年1月1日，0时0分0秒
	// 到当前日期所花费的毫秒数
	var time = d2.getTime();
	console.log(time);
	计算机底层在保存时间时使用的都是时间戳