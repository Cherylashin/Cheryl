#函数作用域
	调用函数时创建函数作用域，函数执行完毕后函数作用域销毁
	每调用一次函数就会创建一个新的函数作用域，他们之间是互相独立的
##在函数中不使用var声明的变量都会成为**全局变量**
	b = 10
        function fun2(){
            // var声明提前但未赋值
            console.log(b);
            var b = "函数中的a";
            c = 10;	//虽然是在函数中定义的参数但未使用var相当于创建了全局变量
        }
        fun2();
        console.log(c);------------10

##添加形参之后相当于声明提前后续不加var赋值也不会影响全局变量的值
	// 添加形参
        d = 123;
        function fun3(d){---------------------相当于声明了局部变量d
            console.log(d);-----------------undefined-------------未赋值
            d = 456;----------------改变局部变量d不影响全局变量的值
        }
        fun3();----------------未传入参数
        console.log(d);--------------123
##Google的debug调试
	开发者工具->源代码->选中变量添加监听
![](/img/0803/1.png)

#this
	解析器在调用函数每次都会向函数内部传递进一个隐含的参数，这个隐含的参数就是this
	这个对象我们称为函数执行的上下文对象，根据函数的调用方式的不同，this会指向不同的对象
		1. 以函数的形式调用书，this永远都是window
		2. 以方法的形式调用时，this就是调用方法的那个对象
		function fun(){
			console.log(this.name);
		}
	        
		var obj = {
			name:"swk",
			sayName:fun
		};

		//以方法的形式调用，this表示的是obj对象的属性，obj.name=="swk"
		obj.sayName();---------------------------swk  
	
		name = "全局的name属性";
		//以函数形式调用，this表示的是window的属性，window.name="全局的name属性"
		fun(); ------------------------全局的name属性

#使用工厂方法创建对象（用的不多）
	function createPerson(name,age){
            var obj = new Object();

            obj.name = name;
            obj.age = age;
            return obj;
        }

        var obj3 = createPerson("zbj",20);
        console.log(obj3);-------------------{name: 'zbj', age: 20}

	使用工厂方法创建的对象使用的构造函数都是Object，
	所以创建的对象都是Object这个类型导致我们无法区分出多种不同的数据类型
#构造函数
	构造函数和普通函数的局别就是调用方式不同
		普通函数直接调用，构造函数：new 构造函数()
	构造函数的执行流程：
		1. 立刻创建一个新的对象
		2. 将新建的对象设置为函数中this，在构造函数中可以使用this来引用新建的对象(如下图中this相当于新建的obj对象)
		3. 逐行执行函数中的代码
		4. 将新建的对象作为返回值返回
![](/img/0803/2.png)

	使用instanceof可以检查一个对象是不是一个类的实例：
	语法：
		对象 instanceof 构造函数，是返回true
		console.log(obj instanceof Person);----------------true